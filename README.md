# mirrorarch
While studying and describing the behavior of my fully Turning complete key derivation mechanism, which is part of mirrormachine, I came to a realisation:
_It is Turning complete._ It has instruction set. It is programmable. It is programmable by natural entropy.

It is essentialy programmed by entropy by design, but the program blueprint is constantly changing its
shape thanks to entropic programming being unpredictably but deterministically combined with the entropic string derived from a passphrase. The machine
itself is mutating based on the entropic sources and essentially on previous states as well (this is important, remember this for later). This is, in
the theoretical model, proposed as not being reversible, not even if the observer has full overview of the machine, machine inputs and outputs as well.

And when the thought came to me, that the mirrormachine is essentially a simulation of an ever morphing computer that cannot be compromised by design:
can only go forward one instruction at a time - maintaining code integrity. And the thought thread spanned even further, because we can actually completely
reverse the model. Entropy does not have to be just a birthing nest for instructions: it can be the encoding medium for them.

routines can be integrity dependent or have its own integrity checkpoints in case of interrupts and code will be completely impossible
to reverse engineer or compromise - since each instruction will be uniquely encrypted and 1:1 executed as such by design.
Instructions are but a mist that never comes to existance, yet if the right path was followed to reach them, they take the right shape.
